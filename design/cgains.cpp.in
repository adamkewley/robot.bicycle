#include <algorithm>
#include "cgains.h"

namespace cg {

const std::array<ControllerGains, num_gains> gains = {{ "{{" }}
  /* ------------------ AUTOGENERATED CODE STARTS HERE ------------------- */
{% for k in range(NUMGAINS) %}
  { /* -------------- CONTROLLER GAINS FOR SPEED {{ k }} START -------------- */
{% for M in [(AROWS, ACOLS, "A_c"), (BROWS, BCOLS, "B_c"), (CROWS, CCOLS, "C_c")] %}
  { /* Matrix {{ M[2][0] }} in rowmajor order */
{% for i in range(M[0]) %}
{% set i_loop = loop %}
{% for j in range(M[1]) %}
{% if not (loop.last and i_loop.last) %}
    {{ GAINS[k][M[2]][i, j] }}f,
{% else %}
    {{ GAINS[k][M[2]][i, j] }}f
{% endif %}
{% endfor %}
{% endfor %}
  },
{% endfor %}
  {{ SPEED[k] }}f /* theta_R_dot at speed */
{% if not loop.last %}
  }, /* -------------- CONTROLLER GAINS FOR SPEED {{ k }} END --------------- */
{% else %}
  } /* --------------- CONTROLLER GAINS FOR SPEED {{ k }} END --------------- */
{% endif %}
{% endfor %}
{{ "}}" }}; /* gains */

void lu_bounds(float theta_R_dot, const ControllerGains * ar[2]) {
  static ControllerGains temp;
  temp.theta_R_dot = theta_R_dot;
  // Assumption: gains are in sorted order (smallest to largest)
  auto up = std::upper_bound(gains.begin(), gains.end(), temp);
  if (up == gains.end()) { // signed rear wheel rate is greater than greatest rear wheel rate output
    ar[0] = up;
    ar[1] = nullptr;
  } else if (up == gains.begin()) {  // signed rear wheel rate is lower than lowest rear wheel rate output
    ar[0] = nullptr;
    ar[1] = up;
  } else { // normal case when speed is inside range
    ar[0] = up - 1;
    ar[1] = up;
  }
}

bool state_and_output_update(float theta_R_dot, const float input[3], float x[5], float & y)
{
  // Obtain references to Controller gains at speeds which bound measured speed
  const cg::ControllerGains * ar[2];
  cg::lu_bounds(theta_R_dot, ar);

  // Only perform update if speed is inside range
  if ((ar[0] != nullptr) && // wheel rate is is greater than lower bound
      (ar[1] != nullptr)) { // wheel rate is less than upper bound
    // Compute state update
    // controller inputs are:
    //   - yaw rate reference,
    //   - steer angle measurement
    //   - roll rate measurement
    const float run = ar[1]->theta_R_dot - ar[0]->theta_R_dot;
    const float d_theta_R_dot = theta_R_dot - ar[0]->theta_R_dot;
    const float alpha = d_theta_R_dot / run;
    float rise;

    float x_new[2*cg::a_rows] = {0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f};
    for (int i = 0; i < cg::a_rows; ++i) {   // rows of state equations
      for (int j = 0; j < cg::a_cols; ++j) {    // columns of A * rows of x
        x_new[i] += ar[0]->A[cg::a_cols*i + j] * x[j];
        x_new[cg::a_cols + i] += ar[1]->A[cg::a_cols*i + j] * x[j];
      } // for j
      for (int j = 0; j < cg::b_cols; ++j) {    // columns of B * rows of controller input
        x_new[i] += ar[0]->B[cg::b_cols*i + j] * input[j];
        x_new[cg::a_cols + i] += ar[1]->B[cg::b_cols*i + j] * input[j];
      } // for j
    } // for i

    // Interpolate the two gains and update the state
    for (int i = 0; i < 5; ++i) {
      rise = x_new[cg::a_cols + i] - x_new[i];
      x[i] = rise * alpha + x_new[i];
    }

    // Compute controller output using updated state
    float y_lu[2] = {0.0f, 0.0f};
    for (int i = 0; i < 5; ++i) {
      y_lu[0] += ar[0]->C[i] * x[i];
      y_lu[1] += ar[1]->C[i] * x[i];
    } // for i
    // Interpolate
    rise = y_lu[1] - y_lu[0];
    y = rise * alpha + y_lu[0];
    return true;
  }
  return false;
}

} /* namespace cg */

