#include "cgains.h"

namespace cg {
	it_t CGArray::upper_bound(const_it_t first,
							  const_it_t last, float value) const {
		it_t it;
		it_t front = const_cast<it_t>(first);
		std::iterator_traits<it_t>::difference_type count, step;
		count = std::distance(front, const_cast<it_t>(last));
		while (count > 0) {
			it = front;
			step = count / 2;
			std::advance(it, step);
			if (value >= it->theta_R_dot) {
				front = ++it;
				count -= step + 1;
			} else {
				count = step;
			}
		}
		return front;
	}
	std::pair<ControllerGains*, ControllerGains*> lu_bounds(float x) const;
		auto upper = upper_bound(cg_array.begin(), cg_array.end(), x);
		if (upper == cg_array.begin())
			return std::make_pair(0, upper);
		auto lower = upper - 1;
		if (upper == cg_array.end())
			return std::make_pair(lower, 0);
		return std::make_pair(lower, upper);
	}
	CGArray gains {{ "{{{" }}
	/* ------------------ AUTOGENERATED CODE STARTS HERE ------------------- */
{% for k in range(NUMGAINS) %}
		{ /* -------------- CONTROLLER GAINS FOR SPEED {{ k }} START -------------- */
{% for M in [(AROWS, ACOLS, "A_c"), (BROWS, BCOLS, "B_c"), (CROWS, CCOLS, "C_c")] %}
			{{ "{{" }} /* Matrix {{ M[2][0] }} in rowmajor order */
{% for i in range(M[0]) %}
{% set i_loop = loop %}
{% for j in range(M[1]) %}
{% if not (loop.last and i_loop.last) %}
				{{ GAINS[k][M[2]][i, j] }}f,
{% else %}
				{{ GAINS[k][M[2]][i, j] }}f
{% endif %}
{% endfor %}
{% endfor %}
			{{ "}}" }},
{% endfor %}
			{{ SPEED[k] }}f /* theta_R_dot at speed */
{% if not loop.last %}
		}, /* -------------- CONTROLLER GAINS FOR SPEED {{ k }} END --------------- */
{% else %}
		} /* --------------- CONTROLLER GAINS FOR SPEED {{ k }} END --------------- */
{% endif %}
{% endfor %}
	{{ "}}}" }}; /* gains */
} /* namespace cg */
