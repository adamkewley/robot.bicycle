#include <algorithm>
#include "YawRateController.h"

const std::array<cg::ControllerGains, cg::num_gains> YawRateController::gains_ = {{ "{{" }}
  /* ------------------ AUTOGENERATED CODE STARTS HERE ------------------- */
{% for k in range(NUMGAINS) %}
  { /* -------------- CONTROLLER GAINS FOR SPEED {{ k }} START -------------- */
{% for M in [(AROWS, ACOLS, "A_c"), (BROWS, BCOLS, "B_c"), (CROWS, CCOLS, "C_c")] %}
  { /* Matrix {{ M[2][0] }} in rowmajor order */
{% for i in range(M[0]) %}
{% set i_loop = loop %}
{% for j in range(M[1]) %}
{% if not (loop.last and i_loop.last) %}
    {{ GAINS[k][M[2]][i, j] }}f,
{% else %}
    {{ GAINS[k][M[2]][i, j] }}f
{% endif %}
{% endfor %}
{% endfor %}
  },
{% endfor %}
  {{ SPEED[k] }}f /* theta_R_dot at speed */
{% if not loop.last %}
  }, /* -------------- CONTROLLER GAINS FOR SPEED {{ k }} END --------------- */
{% else %}
  } /* --------------- CONTROLLER GAINS FOR SPEED {{ k }} END --------------- */
{% endif %}
{% endfor %}
{{ "}}" }}; /* gains */

bool YawRateController::lu_bounds(float theta_R_dot) {
  static cg::ControllerGains temp;
  temp.theta_R_dot = theta_R_dot;
  // Assumption: gains are in sorted order (smallest to largest)
  auto up = std::upper_bound(gains_.begin(), gains_.end(), temp);
  if (up == gains_.begin() || up == gains_.end()) {
    return false;
  } else { // normal case when speed is inside range
    ar_[0] = up - 1;
    ar_[1] = up;
    return true;
  }
}

bool YawRateController::state_estimate_update(float theta_R_dot, const float input[cg::b_cols])
{
  if (lu_bounds(theta_R_dot)) { // Only perform update if speed is inside range
    const float run = ar_[1]->theta_R_dot - ar_[0]->theta_R_dot;
    const float d_theta_R_dot = theta_R_dot - ar_[0]->theta_R_dot;
    alpha_ = d_theta_R_dot / run;

    float x_new[2*cg::a_cols] = {0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f};
    for (int i = 0; i < cg::a_rows; ++i) {   // rows of state equations
      for (int j = 0; j < cg::a_cols; ++j) {    // columns of A * rows of x
        x_new[i] += ar_[0]->A[cg::a_cols*i + j] * x_[j];
        x_new[cg::a_cols + i] += ar_[1]->A[cg::a_cols*i + j] * x_[j];
      } // for j
      for (int j = 0; j < cg::b_cols; ++j) {    // columns of B * rows of controller input
        x_new[i] += ar_[0]->B[cg::b_cols*i + j] * input[j];
        x_new[cg::a_cols + i] += ar_[1]->B[cg::b_cols*i + j] * input[j];
      } // for j
    } // for i

    // Interpolate the state updates
    for (int i = 0; i < cg::a_cols; ++i)
      x_[i] = (x_new[cg::a_cols + i] - x_new[i]) * alpha_ + x_new[i];

    return true;
  }
  return false;
}

float YawRateController::control_output_update()
{
  // Compute controller output using updated state
  float y_lu[2] = {0.0f, 0.0f};
  for (int i = 0; i < cg::a_cols; ++i) {
    y_lu[0] += ar_[0]->C[i] * x_[i];
    y_lu[1] += ar_[1]->C[i] * x_[i];
  } // for i
  // Return interpolated output
  return (y_lu[1] - y_lu[0]) * alpha_ + y_lu[0];
}

