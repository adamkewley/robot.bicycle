"""Observer based yaw rate controller with integral action.

"""
from parameters import rear, w
import scipy.io as sio
from scipy.signal import cont2discrete, bode, lti, ss2tf, dstep, freqz
import numpy as np
from numpy import pi, dot, outer
from numpy.matlib import zeros, empty, eye, asmatrix, diag
import numpy.linalg as la
np.set_printoptions(precision=4)
import matplotlib.pyplot as plt
from control_tools import dare
from controller_data import controller_t
from control.statefbk import ctrb, obsv

# Load data generated by continuous time model of bicycle
data = np.load('robotic_bicycle_linear_dynamics_vs_logspeed.npz')
radius = rear.R
#data = np.load('benchmark_bicycle_linear_dynamics_vs_logspeed.npz')
#radius = w.rR

skip = 1
theta_R_dot = data['theta_R_dot'][::skip]
A_w = data['A_w'][::skip]
B_w = data['B_w'][::skip]
C_w = data['C_w'][::skip]   # steer, roll rate, yaw rate measurements
N = len(theta_R_dot)

def plot_evals():
    evals = np.zeros((N, 4), dtype=np.complex128)
    for i, A in enumerate(A_w):
        evals[i], _ = la.eig(A)

    plt.figure()
    plt.plot(-theta_R_dot*radius, evals.real, 'k.')
    plt.plot(-theta_R_dot*radius, evals.imag, 'b.')

def compute_gains(Q, R, W, V, dt):
    """Given LQR Q and R matrices, and Kalman W and V matrices, and sample
    time, compute optimal feedback gain and optimal filter gains."""

    c_data = np.empty((N,), dtype=controller_t)

    # Loop over all speeds for which we have system dynamics
    for i in range(N):
        c_data['theta_R_dot'][i] = theta_R_dot[i]
        c_data['dt'][i] = dt
        # Convert the bike dynamics to discrete time using a zero order hold
        c_data['A'][i], c_data['B'][i], _, _, _ = cont2discrete(
                        (A_w[i], B_w[i, :], eye(4), zeros((4, 1))), dt)
        c_data['plant_evals'][i] = la.eigvals(c_data['A'][i])

        # Steer input matrix
        B_delta = asmatrix(c_data['B'][i, :, 2]).T
        # Bicycle output matrices
        c_data['C'][i] = C_w[i]

        # Controllability and observability matrix
        A = c_data['A'][i]
        B = c_data['B'][i][:,2].reshape((4,1))
        C = c_data['C'][i][:2, :]
        c_data['Ctrb'][i] = ctrb(A, B)
        c_data['Obsv'][i] = obsv(A, C)

        # Plant dynamics and input matrices for LQR design
        A_lqr = zeros((5, 5))
        A_lqr[:4, :4] = c_data['A'][i]
        A_lqr[4, :4] = -C_w[i, 2, :] * dt
        A_lqr[4, 4] = 1.0
        B_lqr = zeros((5, 1))
        B_lqr[:4, 0] = B_delta

        # Solve discrete algebraic Ricatti equation associated with LQR problem
        P_c = dare(A_lqr, B_lqr, R, Q)

        # Form optimal feedback gain using solution of Ricatti equation
        c_data['F'][i] = -la.solve(R + B_lqr.T*P_c*B_lqr, B_lqr.T*P_c*A_lqr)
        c_data['A_c'][i] = A_lqr + B_lqr*c_data['F'][i]
        c_data['controller_evals'][i] = la.eigvals(c_data['A_c'][i])
        B_c = zeros((5, 3))
        B_c[:4, :2] = c_data['B'][i, :4, :2]
        B_c[4, 2] = dt
        c_data['B_c'][i] = B_c
        c_data['C_c'][i] = np.hstack((c_data['C'][i, 2, :], 0))

        # Kalman filter design
        C_m = asmatrix(c_data['C'][i, :2, :])
        P_e = dare(c_data[i]['A'].T, C_m.T, V, W)
        K_c = P_e*C_m.T*la.inv(C_m*P_e*C_m.T + V)
        c_data['K_c'][i] = K_c
        c_data['A_e'][i] = dot(eye(4) - K_c*C_m, c_data['A'][i])
        c_data['B_e'][i] = np.hstack((dot(eye(4) - K_c*C_m, B_delta), K_c))
        c_data['estimator_evals'][i] = la.eigvals(c_data['A_e'][i])

        # Form combined controller/estimator matrices
        A_ce = np.zeros((5, 5))
        A_ce[:4, :5] = (np.hstack((c_data['A_e'][i], zeros((4, 1))))
                      + dot(eye(4) - dot(K_c, C_m), dot(B_delta,
                          c_data['F'][i])))
        A_ce[4, :] = A_lqr[4, :]
        c_data['A_ce'][i] = A_ce
        c_data['B_ce'][i] = np.zeros((5, 3))
        c_data['B_ce'][i, 4, 0] = dt
        c_data['B_ce'][i, :4, 1:] = K_c
        # Note that controller estimator dynamics may be unstable.
        # Once connected to plant however, the closed loop must be stable.
        c_data['controller_estimator_evals'][i] = la.eigvals(A_ce)

        # Transfer function from roll rate measurement noise to output steer
        # torque
        num, den = ss2tf(A_ce, c_data['B_ce'][i, :, 2].reshape((5,1)),
                         c_data['F'][i], 0)
        c_data['w_n_to_u'][i], y = freqz(num[0], den)
        c_data['w_n_to_u'][i] /= (dt * 2.0 * np.pi)
        c_data['mag_n_to_u'][i] = 20.0 * np.log10(abs(y))
        c_data['phase_n_to_u'][i] = np.unwrap(np.angle(y)) * 180.0 / np.pi

        # Form closed loop state matrices
        A_cl_ul = c_data['A'][i]
        A_cl_ur = outer(B_delta, c_data['F'][i])
        A_cl_ll = np.vstack((K_c * C_m,zeros((1, 4))))
        A_cl_lr = c_data['A_ce'][i]
        A_cl = np.vstack((np.hstack((A_cl_ul, A_cl_ur)),
                          np.hstack((A_cl_ll, A_cl_lr))))
        c_data['A_cl'][i] = A_cl
        B_cl = np.zeros((9, 9))
        B_cl[:4, :2] = c_data['B'][i, :, :2]
        B_cl[:4, 2:6] = eye(4)
        B_cl[4:8, 7:] = c_data['K_c'][i]
        B_cl[8, 6] = dt
        c_data['B_cl'][i] = B_cl
        c_data['C_cl'][i] = np.hstack((c_data['C'][i, 2, :], np.zeros((5,))))
        c_data['closed_loop_evals'][i] = la.eigvals(A_cl)

        B_cl_r = asmatrix(B_cl[:, 5]).T
        num, den = ss2tf(A_cl, B_cl_r, c_data['C_cl'][i], 0)
        c_data['w_cl'][i], y = freqz(num[0], den)
        c_data['w_cl'][i] /= (dt * 2.0 * np.pi)
        c_data['mag_cl'][i] = 20.0 * np.log10(abs(y))
        c_data['phase_cl'][i] = np.unwrap(np.angle(y)) * 180.0 / np.pi


    # Some operations can be vectorized instead of being doing inside main loop
    # Plant natural frequency, damping ratio, time constant
    c_data['plant_evals_c'] = np.log(c_data['plant_evals']) / dt
    c_data['wn_p'] = np.abs(np.log(c_data['plant_evals'])) / dt
    c_data['zeta_p'] = -np.cos(np.angle(np.log(c_data['plant_evals'])))
    c_data['tau_p'] = 1.0/(c_data['wn_p']*c_data['zeta_p'])

    # Controller natural frequency, damping ratio, time constant
    c_data['controller_evals_c'] = np.log(c_data['controller_evals']) / dt
    c_data['wn_c'] = np.abs(np.log(c_data['controller_evals'])) / dt
    c_data['zeta_c'] = -np.cos(np.angle(np.log(c_data['controller_evals'])))
    c_data['tau_c'] = 1.0/(c_data['wn_c']*c_data['zeta_c'])

    # Estimator natural frequency, damping ratio, time constant
    c_data['estimator_evals_c'] = np.log(c_data['estimator_evals']) / dt
    c_data['wn_e'] = np.abs(np.log(c_data['estimator_evals'])) / dt
    c_data['zeta_e'] = -np.cos(np.angle(np.log(c_data['estimator_evals'])))
    c_data['tau_e'] = 1.0/(c_data['wn_e']*c_data['zeta_e'])

    # Combined controller & estimator
    c_data['controller_estimator_evals_c'] = np.log(c_data['controller_estimator_evals']) / dt
    c_data['wn_ce'] = np.abs(np.log(c_data['controller_estimator_evals'])) / dt
    c_data['zeta_ce'] = -np.cos(np.angle(np.log(c_data['controller_estimator_evals'])))
    c_data['tau_ce'] = 1.0/(c_data['wn_ce']*c_data['zeta_ce'])

    # Closed loop natural frequency, damping ratio, time constant
    c_data['closed_loop_evals_c'] = np.log(c_data['closed_loop_evals']) / dt
    c_data['wn_cl'] = np.abs(np.log(c_data['closed_loop_evals'])) / dt
    c_data['zeta_cl'] = -np.cos(np.angle(np.log(c_data['closed_loop_evals'])))
    c_data['tau_cl'] = 1.0/(c_data['wn_cl']*c_data['zeta_cl'])

    return c_data

def design_controller():
    dt = 0.005
    # State weighting matrix Q
    Q = diag([(10*pi/180)**(-2), (10*pi/180)**(-2),
                 (100*pi/180)**(-2), (100*pi/180)**(-2),
                 (10*pi/180)**(-2)])

    # Control input weighting matrix R
    R = diag([10])

    # State error covariance
    W = diag([0.0, 0.0, .001, .001]) * dt

    # Measurement error covariance
    V = diag([(10.0/20000*2.0*pi)**2.,
              (1000/(2**16)*500*pi/180)**2])

    # Calculate closed loop eigenvalues and gains
    return compute_gains(Q, R, W, V, dt)


def main():
    c_data = design_controller()
    np.savez("controller_data.npz", c_data)


if __name__ == "__main__":
    main()

