"""Observer based yaw rate controller with integral action.

"""
from parameters import rear, w
import scipy.io as sio
from scipy.signal import cont2discrete, bode
import numpy as np
from numpy import pi, dot, outer
from numpy.matlib import zeros, empty, eye, asmatrix, diag
import numpy.linalg as la
np.set_printoptions(precision=4)
import matplotlib.pyplot as plt
from control_tools import dare
from controller import controller_t

# Load data generated by continuous time model of bicycle
data = np.load('robotic_bicycle_linear_dynamics_vs_logspeed.npz')
radius = rear.R
#data = np.load('benchmark_bicycle_linear_dynamics_vs_logspeed.npz')
#radius = w.rR

skip = 10
theta_R_dot = data['theta_R_dot'][::skip]
A_w = data['A_w'][::skip]
B_w = data['B_w'][::skip]
C_w = data['C_w'][::skip]   # steer, roll rate, yaw rate measurements
N = len(theta_R_dot)

def plot_evals():
    evals = np.zeros((N, 4), dtype=np.complex128)
    for i, A in enumerate(A_w):
        evals[i], _ = la.eig(A)

    plt.figure()
    plt.plot(-theta_R_dot*radius, evals.real, 'k.')
    plt.plot(-theta_R_dot*radius, evals.imag, 'b.')

def compute_gains(Q, R, W, V, dt):

    c_data = np.empty((N,), dtype=controller_t)

    # Loop over all speeds for which we have system dynamics
    for i in range(N):

        c_data['theta_R_dot'][i] = theta_R_dot[i]
        c_data['dt'][i] = dt
        # Convert the bike dynamics to discrete time using a zero order hold
        c_data['A'][i], c_data['B'][i], _, _, _ = cont2discrete(
                        (A_w[i], B_w[i, :], eye(4), zeros((4, 1))), dt)

        # Bicycle output matrices
        c_data['C'][i] = C_w[i]

        # Augmented LQR controller state matrices
        c_data['A_c'][i, :4, :4] = c_data['A'][i]
        c_data['A_c'][i, :4, 4] = np.zeros((4,))
        c_data['A_c'][i, 4, :4] = -C_w[i, 2, :] * dt
        c_data['A_c'][i, 4, 4] = 1
        c_data['B_c'][i, :4] = np.array([c_data['B'][i, :, 2]]).T
        c_data['B_c'][i, 4, 0] = 0

        # Get the closed loop eigenvalues and optimal gain as determined by
        # solving the discrete algebraic Riccati equation
        Aa = asmatrix(c_data['A_c'][i])
        Ba = asmatrix(c_data['B_c'][i])
        P_c = dare(Aa, Ba, R, Q)
        c_data['F'][i] = -la.solve(R + Ba.T*P_c*Ba, Ba.T*P_c*Aa)
        c_data['controller_evals'][i] = la.eigvals(Aa + Ba*c_data['F'][i])

        C = asmatrix(c_data['C'][i, :2, :])
        P_e = dare(c_data[i]['A'].T, C.T, V, W)
        c_data['A_e'][i] = dot(eye(4) - c_data['K_c'][i]*C, c_data['A'][i])
        c_data['K_c'][i] = P_e*C.T*la.inv(C*P_e*C.T + V)
        c_data['estimator_evals'][i] = la.eigvals(c_data['A_e'][i])

        # Form combined controller/estimator matrices
        A_ce = np.zeros((5,5))
        A_ce[:4, :4] = c_data['A_e'][i] + dot(dot(c_data['K_c'][i], C),
                                              dot(c_data['B'][i], c_data['

        # Form closed loop state matrices
        A_cl_ul = c_data['A'][i]
        A_cl_ur = outer(c_data['B'][i, :, 2], c_data['F'][i])
        A_cl_ll = dot(np.vstack((c_data['K_c'][i], np.zeros((1,2)))),
                      c_data['C'][i, :2, :])
        A_cl_lr = c_data['A_c'][i]
        c_data['A_cl'][i] = np.vstack((np.hstack((A_cl_ul, A_cl_ur)),
                                       np.hstack((A_cl_ll, A_cl_lr))))

        B_cl = np.zeros((9, 5))
        B_cl[8, 0] = dt                         # Reference
        B_cl[4:8, 1:3] = c_data['K_c'][i]       # Noise
        B_cl[:4, 3:] = c_data['B'][i, :, :2]    # Disturbance
        c_data['B_cl'][i] = B_cl
        c_data['C_cl'][i] = np.hstack((c_data['C'][i, 2, :], np.zeros((5,))))

        c_data['closed_loop_evals'][i] = la.eigvals(c_data['A_cl'][i])

        w = np.logspace(-1, 2, 100)
        #c_data['w'][i], c_data['mag_cl'][i], c_data['phase_cl'] = bode((


    # Some operations can be vectorized instead of being doing inside main loop
    # Controller natural frequency, damping ratio, time constant
    c_data['wn_c'] = np.abs(np.log(c_data['controller_evals'])) / dt
    c_data['zeta_c'] = -np.cos(np.angle(np.log(c_data['controller_evals'])))
    c_data['tau_c'] = 1.0/(c_data['wn_c']*c_data['zeta_c'])

    # Estimator natural frequency, damping ratio, time constant
    c_data['wn_e'] = np.abs(np.log(c_data['estimator_evals'])) / dt
    c_data['zeta_e'] = -np.cos(np.angle(np.log(c_data['estimator_evals'])))
    c_data['tau_e'] = 1.0/(c_data['wn_e']*c_data['zeta_e'])

    # Closed loop natural frequency, damping ratio, time constant
    c_data['wn_cl'] = np.abs(np.log(c_data['closed_loop_evals'])) / dt
    c_data['zeta_cl'] = -np.cos(np.angle(np.log(c_data['closed_loop_evals'])))
    c_data['tau_cl'] = 1.0/(c_data['wn_cl']*c_data['zeta_cl'])

    return c_data

def design_controller():
    dt = 0.005
    # State weighting matrix Q
    Q = diag([(10*pi/180)**(-2), (10*pi/180)**(-2),
                 (100*pi/180)**(-2), (100*pi/180)**(-2),
                 (10*pi/180)**(-2)])

    # Control input weighting matrix R
    R = diag([.1])

    # State error covariance
    W = diag([0.0, 0.0, .001, .001]) * dt

    # Measurement error covariance
    V = diag([(10.0/20000*2.0*pi)**2.,
              (100/(2**16)*500*pi/180)**2])

    # Calculate closed loop eigenvalues and gains
    return compute_gains(Q, R, W, V, dt)

def main():
    #plot_evals()

    c_data = design_controller()

    # State feedback gains versus speed
    plt.figure()
    ax = plt.plot(-theta_R_dot*radius, c_data['F'][:,:,:].reshape((N, 5)))
    ax[0].set_label(r"$k_\phi$")
    ax[1].set_label(r"$k_\delta$")
    ax[2].set_label(r"$k_\dot{\phi}$")
    ax[3].set_label(r"$k_\dot{\delta}$")
    ax[4].set_label(r"$k_\i$")
    plt.legend(loc=0)
    plt.title('Feedback gains vs. speed')
    plt.xlabel('Speed [m / s]')
    plt.ylabel('Gain')

    plt.figure()
    ax = plt.plot(c_data['controller_evals'][:].real,
                  c_data['controller_evals'][:].imag, 'k.')
    plt.title('Closed loop controller eigenvalues')
    plt.xlabel('Imaginary')
    plt.ylabel('Real')
    plt.axis((-1, 1, -1, 1))

    # Estimator gains versus speed (first column, associated with steer angle
    # measurement)
    plt.figure()
    ax = plt.plot(-theta_R_dot*radius, c_data['K_c'][:, :, 0])
    ax[0].set_label(r"$k_\phi$")
    ax[1].set_label(r"$k_\delta$")
    ax[2].set_label(r"$k_\dot{\phi}$")
    ax[3].set_label(r"$k_\dot{\delta}$")
    plt.title("Observer steer angle gains")
    plt.legend(loc=0)

    # Estimator gains versus speed (second column, associated with roll rate
    # measurement)
    plt.figure()
    ax = plt.plot(-theta_R_dot*radius, c_data['K_c'][:, :, 1])
    ax[0].set_label(r"$k_\phi$")
    ax[1].set_label(r"$k_\delta$")
    ax[2].set_label(r"$k_\dot{\phi}$")
    ax[3].set_label(r"$k_\dot{\delta}$")
    plt.legend(loc=0)
    plt.title("Observer roll rate gains")

    # Estimator gains versus speed (third column, associated with yaw rate

    plt.figure()
    ax = plt.plot(c_data['estimator_evals'][:].real,
                  c_data['estimator_evals'][:].imag, 'k.')
    plt.title('Closed loop estimator eigenvalues')
    plt.xlabel('Imaginary')
    plt.ylabel('Real')
    plt.axis((-1, 1, -1, 1))

    plt.show()

if __name__ == "__main__":
    main()
