"""Observer based yaw rate controller with integral action.

"""
from parameters import rear, w
import scipy.io as sio
from scipy.signal import cont2discrete, bode, lti, ss2tf, dstep, freqz, ss2zpk
import numpy as np
from numpy import pi, dot
from numpy.matlib import zeros, empty, eye, asmatrix, diag
import numpy.linalg as la
np.set_printoptions(precision=4)
import matplotlib.pyplot as plt
from control_tools import dare
from controller_data import controller_t
from control.statefbk import ctrb, obsv

# Load data generated by continuous time model of robot bicycle
data = np.load('robotic_bicycle_linear_dynamics_vs_logspeed.npz')
radius = rear.R

# Load data generated by continuous time model of benchmark bicycle
#data = np.load('benchmark_bicycle_linear_dynamics_vs_logspeed.npz')
#radius = w.rR

skip = 1
theta_R_dot = data['theta_R_dot'][::skip]
A_w = data['A_w'][::skip]
B_w = data['B_w'][::skip]
C_w = data['C_w'][::skip]   # steer, roll rate, yaw rate measurements
N = len(theta_R_dot)

def plot_evals():
    evals = np.zeros((N, 4), dtype=np.complex128)
    for i, A in enumerate(A_w):
        evals[i], _ = la.eig(A)

    plt.figure()
    plt.plot(-theta_R_dot*radius, evals.real, 'k.')
    plt.plot(-theta_R_dot*radius, evals.imag, 'b.')

def compute_gains(Q, R, W, V, dt):
    """Given LQR Q and R matrices, and Kalman W and V matrices, and sample
    time, compute optimal feedback gain and optimal filter gains."""

    data = np.empty((N,), dtype=controller_t)

    # Loop over all speeds for which we have system dynamics
    for i in range(N):
        data['theta_R_dot'][i] = theta_R_dot[i]
        data['dt'][i] = dt
        # Convert the bike dynamics to discrete time using a zero order hold
        data['A'][i], data['B'][i], _, _, _ = cont2discrete(
                        (A_w[i], B_w[i, :], eye(4), zeros((4, 1))), dt)
        data['plant_evals'][i] = la.eigvals(data['A'][i])
        data['plant_evals_c'][i] = np.log(data['plant_evals'][i]) / dt

        # Steer input matrix
        B_delta = data['B'][i, :, 2].reshape((4, 1))
        # Bicycle output matrices
        # - steer angle
        # - roll rate
        # - yaw rate
        data['C'][i] = C_w[i]

        # Controllability from steer torque
        data['ctrb_plant'][i] = ctrb(data['A'][i], B_delta)
        u, s, v = la.svd(data['ctrb_plant'][i])
        assert(np.all(s > 1e-13))
        # Observability from steer angle and roll rate measurement
        data['obsv_plant'][i] = obsv(data['A'][i], data['C'][i, :2, :])
        u, s, v = la.svd(data['obsv_plant'][i])
        assert(np.all(s > 1e-13))

        # Plant dynamics and input matrices for LQI design
        A_cp = zeros((5, 5))
        A_cp[:4, :4] = data['A'][i]       # Upper left block
        A_cp[4, :4] = -C_w[i, 2, :] * dt  # Lower left block
        A_cp[4, 4] = 1.0                  # Lower right block
        B_cp = zeros((5, 1))
        B_cp[:4, 0] = B_delta
        # Solve discrete algebraic Ricatti equation associated with LQI problem
        P_c = dare(A_cp, B_cp, R, Q)

        # Optimal feedback gain using solution of Ricatti equation
        K_c = -la.solve(R + dot(B_cp.T, dot(P_c, B_cp)),
                                 dot(B_cp.T, dot(P_c, A_cp)))
        data['K_c'][i] = K_c
        data['A_cp'][i] = A_cp + dot(B_cp, K_c)
        data['B_cp'][i] = np.array([0, 0, 0, 0, dt]).reshape((5, 1))
        data['C_cp'][i] = np.hstack((C_w[i, 2, :].reshape((1, 4)), [[0]]))
        data['controller_evals'][i] = la.eigvals(data['A_cp'][i])
        data['controller_evals_c'] = np.log(data['controller_evals'][i]) / dt
        # Verify that LQR controller eigenvalues are stable
        assert(np.all(abs(data['controller_evals'][i]) < 1.0))

        # Kalman filter design
        # Plant input matrix: steer torque and yaw rate reference input
        B_ep = zeros((5, 2))
        B_ep[:4, 0] = data['B'][i, :4, 2].reshape((4, 1))
        B_ep[4, 1] = dt

        # Plant measurement matrix:
        #  - steer angle
        #  - roll rate
        #  - integral of yaw rate error
        C_ep = np.array([[0, 1, 0, 0, 0],
                         [0, 0, 1, 0, 0],
                         [0, 0, 0, 0, 1]])

        # Solve DARE
        A_ep = A_cp
        P_e = dare(A_ep.T, C_ep.T, V, W)
        # Compute Kalman gain
        K_e = dot(P_e, dot(C_ep.T, la.inv(dot(C_ep, dot(P_e, C_ep.T)) + V)))
        data['K_e'][i] = K_e
        data['A_ep'][i] = dot(eye(5) - dot(K_e, C_ep), A_ep)
        data['B_ep'][i] = np.hstack((dot(eye(5) - dot(K_e, C_ep), B_ep), K_e))
        data['C_ep'][i] = C_ep
        data['estimator_evals'][i] = la.eigvals(data['A_ep'][i])
        data['estimator_evals_c'][i] = np.log(data['estimator_evals'][i]) / dt
        # Verify that Kalman estimator eigenvalues are stable
        assert(np.all(abs(data['estimator_evals'][i]) < 1.0))

        # Combined estimator controller equations
        # These are to be implemented on the bicycle firmware
        A_ce = np.zeros((5, 5))
        A_ce += dot(np.eye(5) - dot(K_e, C_ep), A_cp + dot(B_cp, K_c))
        A_ce += dot(K_e[:, 2].reshape((5, 1)), np.array([[0, 0, 0, 0, 1]]))

        B_ce = np.zeros((5, 3))
        B_ce[:, 0] = dot(np.eye(5) - dot(K_e, C_ep), np.array([[0, 0, 0, 0, dt]]).T).T
        B_ce[:, 1:] = K_e[:, :2]

        data['A_ce'][i] = A_ce
        data['B_ce'][i] = B_ce

        # Closed loop state space equations
        A_cl = np.empty((10, 10))
        A_cl[:5, :5] = A_ep
        A_cl[:5, 5:] = dot(B_ep[:, 0].reshape((5, 1)), K_c)
        A_cl[5:, :5] = dot(K_e, dot(C_ep, A_ep))
        A_cl[5:, 5:] = A_ep - A_cl[5:, :5] + A_cl[:5, 5:]

        B_cl = np.empty((10, 1))
        B_cl[:5, 0] = B_ep[:, 1].reshape((5,))
        B_cl[5:, 0] = B_ep[:, 1].reshape((5,))
        data['A_cl'][i] = A_cl
        data['closed_loop_evals'][i] = la.eigvals(A_cl)
        assert(np.all(abs(data['closed_loop_evals'][i]) < 1.0))
        # FIXME:
        data['closed_loop_evals_c'][i] = data['closed_loop_evals'][i] / dt

        data['B_cl'][i] = B_cl

        data['C_cl'][i] = np.hstack((data['C'][i, 2, :].reshape((1, 4)), np.zeros((1, 6))))

        # Closed loop transfer function
        num, den = ss2tf(A_cl, B_cl, data['C_cl'][i], 0)
        data['w_cl'][i], y = freqz(num[0], den)
        data['w_cl'][i] /= (dt * 2.0 * np.pi)
        data['mag_cl'][i] = 20.0 * np.log10(abs(y))
        data['phase_cl'][i] = np.unwrap(np.angle(y)) * 180.0 / np.pi
         
        A_ol = np.zeros((5, 5))
        A_ol[:4, :4] = data['A'][i] + dot(data['B'][i, :, 2].reshape((4, 1)),
                                          K_c[0, :4].reshape((1, 4)))
        A_ol[:4, 4] = data['B'][i, :, 2] * K_c[0, 4]
        A_ol[4, 4] = 1.0
        B_ol = np.zeros((5, 1))
        B_ol[4, 0] = dt
        num, den = ss2tf(A_ol, B_ol, np.hstack((data['C'][i, 2, :], 0)), 0)
        data['w_ol'][i], y = freqz(num[0], den, worN=np.linspace(1e-6, pi, 512))
        data['w_ol'][i] /= (dt * 2.0 * np.pi)
        data['mag_ol'][i] = 20.0 * np.log10(abs(y))
        data['phase_ol'][i] = np.unwrap(np.angle(y)) * 180.0 / np.pi

    return data

def design_controller():
    dt = 0.005
    # State weighting matrix Q
    Q = diag([(100*pi/180)**(-2), (100*pi/180)**(-2),
               (10*pi/180)**(-2), (10*pi/180)**(-2),
               (10*pi/180)**(-2)])

    # Control input weighting matrix R
    R = np.array([[1.0]])

    # State error covariance
    W = diag([0.0, 0.0, 1e-6, 1e-6, 1e-6]) * dt

    # Measurement error covariance
    V = diag([(.1/20000*2.0*pi)**2., # square of .1 count
              (0.00227631723111)**2, # square of std deviation from static
              1e-16])                # Perfect measurement of integral term

    # Calculate closed loop eigenvalues and gains
    return compute_gains(Q, R, W, V, dt)


def main():
    data = design_controller()
    np.savez("controller_data.npz", data)

if __name__ == "__main__":
    main()

