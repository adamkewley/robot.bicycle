"""Observer based yaw rate controller with integral action.

"""
from parameters import rear, w
import scipy.io as sio
from scipy.signal import cont2discrete, bode, lti, ss2tf, dstep
import numpy as np
from numpy import pi, dot, outer
from numpy.matlib import zeros, empty, eye, asmatrix, diag
import numpy.linalg as la
np.set_printoptions(precision=4)
import matplotlib.pyplot as plt
from control_tools import dare
from controller_data import controller_t

# Load data generated by continuous time model of bicycle
data = np.load('robotic_bicycle_linear_dynamics_vs_logspeed.npz')
radius = rear.R
#data = np.load('benchmark_bicycle_linear_dynamics_vs_logspeed.npz')
#radius = w.rR

skip = 20
theta_R_dot = data['theta_R_dot'][::skip]
A_w = data['A_w'][::skip]
B_w = data['B_w'][::skip]
C_w = data['C_w'][::skip]   # steer, roll rate, yaw rate measurements
N = len(theta_R_dot)

def plot_evals():
    evals = np.zeros((N, 4), dtype=np.complex128)
    for i, A in enumerate(A_w):
        evals[i], _ = la.eig(A)

    plt.figure()
    plt.plot(-theta_R_dot*radius, evals.real, 'k.')
    plt.plot(-theta_R_dot*radius, evals.imag, 'b.')

def compute_gains(Q, R, W, V, dt):

    c_data = np.empty((N,), dtype=controller_t)

    # Loop over all speeds for which we have system dynamics
    for i in range(N):
        c_data['theta_R_dot'][i] = theta_R_dot[i]
        c_data['dt'][i] = dt
        # Convert the bike dynamics to discrete time using a zero order hold
        c_data['A'][i], c_data['B'][i], _, _, _ = cont2discrete(
                        (A_w[i], B_w[i, :], eye(4), zeros((4, 1))), dt)
        c_data['plant_evals'][i] = la.eigvals(c_data['A'][i])

        # Steer input matrix
        B_delta = asmatrix(c_data['B'][i, :, 2]).T
        # Bicycle output matrices
        c_data['C'][i] = C_w[i]

        # Plant dynamics and input matrices for LQR design
        A_lqr = zeros((5, 5))
        A_lqr[:4, :4] = c_data['A'][i]
        A_lqr[4, :4] = -C_w[i, 2, :] * dt
        A_lqr[4, 4] = 1.0
        B_lqr = zeros((5, 1))
        B_lqr[:4, 0] = B_delta

        # Solve discrete algebraic Ricatti equation associated with LQR problem
        P_c = dare(A_lqr, B_lqr, R, Q)

        # Form optimal feedback gain using solution of Ricatti equation
        c_data['F'][i] = -la.solve(R + B_lqr.T*P_c*B_lqr, B_lqr.T*P_c*A_lqr)
        c_data['A_c'][i] = A_lqr + B_lqr*c_data['F'][i]
        c_data['controller_evals'][i] = la.eigvals(c_data['A_c'][i])
        B_c = zeros((5, 3))
        B_c[:4, :2] = c_data['B'][i, :4, :2]
        B_c[4, 2] = dt
        c_data['B_c'][i] = B_c
        c_data['C_c'][i] = np.hstack((c_data['C'][i, 2, :], 0))

        # Kalman filter design
        C_m = asmatrix(c_data['C'][i, :2, :])
        P_e = dare(c_data[i]['A'].T, C_m.T, V, W)
        K_c = P_e*C_m.T*la.inv(C_m*P_e*C_m.T + V)
        c_data['K_c'][i] = K_c
        c_data['A_e'][i] = dot(eye(4) - K_c*C_m, c_data['A'][i])
        c_data['B_e'][i] = np.hstack((dot(eye(4) - K_c*C_m, B_delta), K_c))
        c_data['estimator_evals'][i] = la.eigvals(c_data['A_e'][i])

        # Form combined controller/estimator matrices
        A_ce = np.zeros((5, 5))
        A_ce[:4, :5] = (np.hstack((c_data['A_e'][i], zeros((4, 1))))
                      + dot(eye(4) - dot(K_c, C_m), dot(B_delta,
                          c_data['F'][i])))
        A_ce[4, :] = A_lqr[4, :]
        c_data['A_ce'][i] = A_ce
        c_data['B_ce'][i] = np.zeros((5, 3))
        c_data['B_ce'][i, 4, 0] = dt
        c_data['B_ce'][i, :4, 1:] = K_c
        # Note that controller estimator dynamics may be unstable.
        # Once connected to plant however, the closed loop must be stable.
        c_data['controller_estimator_evals'][i] = la.eigvals(A_ce)
        
        # Form closed loop state matrices
        A_cl_ul = c_data['A'][i]
        A_cl_ur = outer(B_delta, c_data['F'][i])
        A_cl_ll = np.vstack((K_c * C_m,zeros((1, 4))))
        A_cl_lr = c_data['A_ce'][i]
        A_cl = np.vstack((np.hstack((A_cl_ul, A_cl_ur)),
                          np.hstack((A_cl_ll, A_cl_lr))))
        c_data['A_cl'][i] = A_cl
        B_cl = np.zeros((9, 9))
        B_cl[:4, :2] = c_data['B'][i, :, :2]
        B_cl[:4, 2:6] = eye(4)
        B_cl[4:8, 7:] = c_data['K_c'][i]
        B_cl[8, 6] = dt
        c_data['B_cl'][i] = B_cl
        c_data['C_cl'][i] = np.hstack((c_data['C'][i, 2, :], np.zeros((5,))))
        c_data['closed_loop_evals'][i] = la.eigvals(A_cl)

        B_cl_r = asmatrix(B_cl[:, 5]).T
        num, den = ss2tf(A_cl, B_cl_r, c_data['C_cl'][i], 0)
        c_data['w'][i], c_data['mag_cl'][i], c_data['phase_cl'][i] = bode((num, den))

    # Some operations can be vectorized instead of being doing inside main loop
    # Plant natural frequency, damping ratio, time constant
    c_data['wn_p'] = np.abs(np.log(c_data['plant_evals'])) / dt
    c_data['zeta_p'] = -np.cos(np.angle(np.log(c_data['plant_evals'])))
    c_data['tau_p'] = 1.0/(c_data['wn_p']*c_data['zeta_p'])

    # Controller natural frequency, damping ratio, time constant
    c_data['wn_c'] = np.abs(np.log(c_data['controller_evals'])) / dt
    c_data['zeta_c'] = -np.cos(np.angle(np.log(c_data['controller_evals'])))
    c_data['tau_c'] = 1.0/(c_data['wn_c']*c_data['zeta_c'])

    # Estimator natural frequency, damping ratio, time constant
    c_data['wn_e'] = np.abs(np.log(c_data['estimator_evals'])) / dt
    c_data['zeta_e'] = -np.cos(np.angle(np.log(c_data['estimator_evals'])))
    c_data['tau_e'] = 1.0/(c_data['wn_e']*c_data['zeta_e'])

    # Closed loop natural frequency, damping ratio, time constant
    c_data['wn_cl'] = np.abs(np.log(c_data['closed_loop_evals'])) / dt
    c_data['zeta_cl'] = -np.cos(np.angle(np.log(c_data['closed_loop_evals'])))
    c_data['tau_cl'] = 1.0/(c_data['wn_cl']*c_data['zeta_cl'])

    return c_data

def design_controller():
    dt = 0.005
    # State weighting matrix Q
    Q = diag([(10*pi/180)**(-2), (10*pi/180)**(-2),
                 (100*pi/180)**(-2), (100*pi/180)**(-2),
                 (10*pi/180)**(-2)])

    # Control input weighting matrix R
    R = diag([.1])

    # State error covariance
    W = diag([0.0, 0.0, .001, .001]) * dt

    # Measurement error covariance
    V = diag([(10.0/20000*2.0*pi)**2.,
              (100/(2**16)*500*pi/180)**2])

    # Calculate closed loop eigenvalues and gains
    return compute_gains(Q, R, W, V, dt)

def main():
    #plot_evals()

    c_data = design_controller()

    # State feedback gains versus speed
    plt.figure()
    ax = plt.plot(-theta_R_dot*radius, c_data['F'][:,:,:].reshape((N, 5)))
    ax[0].set_label(r"$k_\phi$")
    ax[1].set_label(r"$k_\delta$")
    ax[2].set_label(r"$k_\dot{\phi}$")
    ax[3].set_label(r"$k_\dot{\delta}$")
    ax[4].set_label(r"$k_\i$")
    plt.legend(loc=0)
    plt.title('Feedback gains vs. speed')
    plt.xlabel('Speed [m / s]')
    plt.ylabel('Gain')

    plt.figure()
    ax = plt.plot(c_data['controller_evals'][:].real,
                  c_data['controller_evals'][:].imag, 'k.')
    plt.title('Closed loop controller eigenvalues')
    plt.xlabel('Imaginary')
    plt.ylabel('Real')
    plt.axis((-1, 1, -1, 1))

    # Estimator gains versus speed (first column, associated with steer angle
    # measurement)
    plt.figure()
    ax = plt.plot(-theta_R_dot*radius, c_data['K_c'][:, :, 0])
    ax[0].set_label(r"$k_\phi$")
    ax[1].set_label(r"$k_\delta$")
    ax[2].set_label(r"$k_\dot{\phi}$")
    ax[3].set_label(r"$k_\dot{\delta}$")
    plt.title("Observer steer angle gains")
    plt.legend(loc=0)

    # Estimator gains versus speed (second column, associated with roll rate
    # measurement)
    plt.figure()
    ax = plt.plot(-theta_R_dot*radius, c_data['K_c'][:, :, 1])
    ax[0].set_label(r"$k_\phi$")
    ax[1].set_label(r"$k_\delta$")
    ax[2].set_label(r"$k_\dot{\phi}$")
    ax[3].set_label(r"$k_\dot{\delta}$")
    plt.legend(loc=0)
    plt.title("Observer roll rate gains")

    # Estimator gains versus speed (third column, associated with yaw rate

    plt.figure()
    ax = plt.plot(c_data['estimator_evals'][:].real,
                  c_data['estimator_evals'][:].imag, 'k.')
    plt.title('Closed loop estimator eigenvalues')
    plt.xlabel('Imaginary')
    plt.ylabel('Real')
    plt.axis((-1, 1, -1, 1))

    # Closed loop bode plots
    for i in range(N):
        f, axarr = plt.subplots(2, 1, sharex=True)
        axarr[0].semilogx(c_data['w'][i], c_data['mag_cl'][i])
        axarr[0].set_title('Closed loop tf, v = {0}'.format(c_data['theta_R_dot'][i]))
        axarr[1].semilogx(c_data['w'][i], c_data['phase_cl'][i])
        t, x = dstep((c_data['A_cl'][i], asmatrix(c_data['B_cl'][i, :, 6]).T,
                      c_data['C_cl'][i], np.zeros((1, 1)), 0.005),
                      t=np.linspace(0, 20, 100))
        plt.figure()
        plt.plot(t, x[0])

    plt.show()

if __name__ == "__main__":
    main()
